#Problem Statement: 
The problem that we are trying to solve is the lack of a unified platform for NFL players to see their games and stats. An NFL player needs to meticulously gameplan his schedule for an upcoming week depending on the time of day the game is played, specific day of the week the game is played, and the opponent. It is important to keep track of all this information in a single unified database. It is also important to be able to keep track of statistics that come from each game that is played, so the player can be fully informed of the worth they are contributing to the team. Players might not have direct access to an online platform or app to allow them to prepare for games and practices, or see play-by-play statistics from previous games which might help them figure out how to train or certain tactics to use against previous opponents.

#Solution Statement: 
The solution we came up with is to create a database that allows players to create a user profile for themselves as well as add games and stats to the previous or upcoming games in their schedule. Once a yearly NFL schedule is out, users can add all of their games to the database, so they can plan their schedules and then keep track of the stats they accumulate. The database interface allows the user to search through different players, games, and statistics, while also being able to add, delete, update, or create new database objects. While on the editor screen for a particular object, a list of the connected objects allows the user to easily travel to the editor page for the corresponding player, game, or stat associated with it. Our user class is called player, which takes information about the player and creates a user. The first domain object is the game class, which records information about all of the games that the player plays. There is a many to many relationship between the player class and game class since many players can be in many of the same or different games depending on the rosters and opponents chosen for the game. The many to many relationship was reified by creating a starting players mapping class to connect the players on the roster for a particular game to the game itself. Finally there is a stats class that records the statistics from each game. There is a one to many relationship between the game and stats class since a single game will have multiple stats for different plays or quarters.

#User: 
The typical user that would use our solution is an NFL player who would input their first name, last name, username, password, email, date of birth, team, position, and jersey number. They would create a user of themselves as well as adding games on their schedule and eventually input stats that they get during those games. The database could be easily converted to accommodate other sport team users, but is primarily for football at this time. Players who are looking to better their game and stay organized so they can schedule training sessions and events before games will be the ones most active on this interface. 

Domain Objects: 
#One domain object that we implemented in our solution is the game class. The game class has a one to many relationship with the mapping class of starting players. There is a many to many relationship between the player (user) class and the game class. The game class has a gameDate attribute, with a date type, which shows the year, month, and day the game is held on. There is a gameTime attribute with a time type, which shows what time the game will be held at, in Eastern Standard Time. Next there is a homeTeam attribute, with a Team enumeration which lists all of the possible NFL teams that could be playing in the game. Finally there is an injured players attribute with an int type, which shows how many players were injured before the game. Another domain object we implemented in our solution is stats class. The stats class has a many to one relationship with the game class. The stats class has an attribute called playNumber with an int type, which shows the play that the statistics are talking about. There is a running yards attribute with an int type, which shows the amount of running yards acquired during the play. There is a touchdown attribute with a boolean type, which says if a touchdown was made during the play. Lastly, there is a flags attribute with an int type, which tells the user how many flags were thrown during the play. 

#Name of Project: 
NFL Scheduler
#Name of Team: 
J&J Solutions
#Team Members:
 Jason Vernoff (Section 1) and Jared Raines (Section 1)
#Brief Description of Project: 
Our team created a database that NFL players could theoretically use to keep track of their games and statistics. 
#UML Link: 
https://lucid.app/documents/view/bae65211-fdc9-411e-b5ff-209cd0f39980



#Description of the user data model: 
The user data model is a class called player. The gameId integer attribute acts as the primary key (ID) for the class. The player class has a firstName, lastName, userName, password, and email attributes, which are all string types. The player class also has a dateOfBirth attribute with a date type, a team attribute of the Team enumeration String type implemented in a separate class, a string position (football position), and a jerseyNumber int data type. Each of the attributes has a setter and getter function to set or retrieve the specific piece of information about the player. There is a List of Game attribute called schedule mapped by player which is a one to many relationship connected to the many to one player (of type Player) in the Game model.

#Description of the two domain object data models: 
One domain object that we implemented in our solution is the game class. The game class has a one to many relationship with the mapping class of starting players. There is a many to many relationship between the player (user) class and the game class. The game class has a gameDate attribute, with a date type. There is a gameTime attribute with a time type. Next there is a homeTeam attribute, with a Team enumeration. Finally there is an injured players attribute with an int type. Another domain object we implemented in our solution is stats class. The stats class has a many to one relationship with the game class. The stats class has an attribute called playNumber with an int type. There is a running yards attribute with an int type. There is a touchdown attribute with a boolean type. Lastly, there is a flags attribute with an int type. 

#Description of the user to domain object relationship: 
There is a many to many relationship between player and game. This is because many different players can have many different games. In the database a mapping table is used to connect the primary keys of connected objects. In the user interface, OneToMany mappings in the model use lists to grab all of the objects with the corresponding foreign key column generated in the database by the code to collect all of the connected objects in the many to many in the lists for players and games respectively.

#Description of the domain object to domain object relationship: 
There is a one to many relationship between game and stats. This is because one game can have many different stats on a variety of different plays. 
Description of portable enumeration(s): 
There is one enumeration called team, which has every single NFL team listed. A class called NFLTeams was created with an enumeration containing all of the string names of NFL teams. The field team in Player and the field opponent/homeTeam in Game is of this type to only allow these team names to be used. The database contains the same, a table containing the names that are connected to those fields in the Player and Game field as a foreign key.

#Description of the user interface requirements: 
	The user interface consists of an initial user interface which shows a list of players, games, and stats combined. This allows the user to click on a specific object to navigate to its editor page or click a button to add a new Player, Game, or Stat respectively. The editor screens of each object shows the current fields of the object with a label at the top telling the user what type of object they are looking at. Buttons allow the user to add a new object again, update it with the save button, delete the object, or hit cancel to navigate to the last screen. The Player and Game editor screens list the objects in the many to many relationship below the editor screen. The player editor lists all of the games the player is in and the game editor lists all of the players in that specific game. The game editor screen also has a stats button which navigates the user to a new screen that lists all of the stats for that particular game, representing the one to many between the game and stats. Each stat can be clicked on to navigate the user to the specific stats editor that was clicked. The stat editor screen also lists the game it is connected to in the many to one relationship between stat and game below the editor options which brings the user back to the game editor screen connected to the object. Each of the objects, Player, Game, and Stats was implemented as a model, DAO, repository, list screen, and editor screen in the project code. The mapping table in the database and UML model was also modeled in the code, but not used. Instead to represent the information in the user interface, lisst of objects were used with queries to new columns in the database tables to link between one to many relationships. 
